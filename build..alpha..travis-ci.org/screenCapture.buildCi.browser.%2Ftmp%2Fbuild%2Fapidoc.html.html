<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/reactjs/reselect#readme">reselect (v3.0.0)</a>
</h1>
<h4>Selectors for Redux.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.reselect">module reselect</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">reselect.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reselect.createSelector">
            function <span class="apidocSignatureSpan">reselect.</span>createSelector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reselect.createSelectorCreator">
            function <span class="apidocSignatureSpan">reselect.</span>createSelectorCreator
            <span class="apidocSignatureSpan">(memoize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reselect.createStructuredSelector">
            function <span class="apidocSignatureSpan">reselect.</span>createStructuredSelector
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reselect.defaultMemoize">
            function <span class="apidocSignatureSpan">reselect.</span>defaultMemoize
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reselect" id="apidoc.module.reselect">module reselect</a></h1>




    <h2>
        <a href="#apidoc.element.reselect.createSelector" id="apidoc.element.reselect.createSelector">
        function <span class="apidocSignatureSpan">reselect.</span>createSelector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSelector = function () {
  for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 &lt; _len2; _key2++) {
    funcs[_key2] = arguments[_key2];
  }

  var recomputations = 0;
  var resultFunc = funcs.pop();
  var dependencies = getDependencies(funcs);

  var memoizedResultFunc = memoize.apply(undefined, [function () {
    recomputations++;
    // apply arguments instead of spreading for performance.
    return resultFunc.apply(null, arguments);
  }].concat(memoizeOptions));

  // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.
  var selector = defaultMemoize(function () {
    var params = [];
    var length = dependencies.length;

    for (var i = 0; i &lt; length; i++) {
      // apply arguments instead of spreading and mutate a local list of params for performance.
      params.push(dependencies[i].apply(null, arguments));
    }

    // apply arguments instead of spreading for performance.
    return memoizedResultFunc.apply(null, params);
  });

  selector.resultFunc = resultFunc;
  selector.recomputations = function () {
    return recomputations;
  };
  selector.resetRecomputations = function () {
    return recomputations = 0;
  };
  return selector;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reselect.createSelectorCreator" id="apidoc.element.reselect.createSelectorCreator">
        function <span class="apidocSignatureSpan">reselect.</span>createSelectorCreator
        <span class="apidocSignatureSpan">(memoize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptions = Array(_len &gt; 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) {
    memoizeOptions[_key - 1] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 &lt; _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }

    var recomputations = 0;
    var resultFunc = funcs.pop();
    var dependencies = getDependencies(funcs);

    var memoizedResultFunc = memoize.apply(undefined, [function () {
      recomputations++;
      // apply arguments instead of spreading for performance.
      return resultFunc.apply(null, arguments);
    }].concat(memoizeOptions));

    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.
    var selector = defaultMemoize(function () {
      var params = [];
      var length = dependencies.length;

      for (var i = 0; i &lt; length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        params.push(dependencies[i].apply(null, arguments));
      }

      // apply arguments instead of spreading for performance.
      return memoizedResultFunc.apply(null, params);
    });

    selector.resultFunc = resultFunc;
    selector.recomputations = function () {
      return recomputations;
    };
    selector.resetRecomputations = function () {
      return recomputations = 0;
    };
    return selector;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reselect.createStructuredSelector" id="apidoc.element.reselect.createStructuredSelector">
        function <span class="apidocSignatureSpan">reselect.</span>createStructuredSelector
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStructuredSelector(selectors) {
  var selectorCreator = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : createSelector;

  if (typeof selectors !== 'object') {
    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead
 received a ' + typeof selectors));
  }
  var objectKeys = Object.keys(selectors);
  return selectorCreator(objectKeys.map(function (key) {
    return selectors[key];
  }), function () {
    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 &lt; _len3; _key3++) {
      values[_key3] = arguments[_key3];
    }

    return values.reduce(function (composition, value, index) {
      composition[objectKeys[index]] = value;
      return composition;
    }, {});
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reselect.defaultMemoize" id="apidoc.element.reselect.defaultMemoize">
        function <span class="apidocSignatureSpan">reselect.</span>defaultMemoize
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultMemoize(func) {
  var equalityCheck = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;

  var lastArgs = null;
  var lastResult = null;
  // we reference arguments instead of spreading them for performance reasons
  return function () {
    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
      // apply arguments instead of spreading for performance.
      lastResult = func.apply(null, arguments);
    }

    lastArgs = arguments;
    return lastResult;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>